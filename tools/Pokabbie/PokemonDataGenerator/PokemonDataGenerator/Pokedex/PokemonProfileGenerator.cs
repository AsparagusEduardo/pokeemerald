using Newtonsoft.Json.Linq;
using PokemonDataGenerator.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace PokemonDataGenerator.Pokedex
{
	public static class PokemonProfileGenerator
	{
		private static readonly string c_API = "https://pokeapi.co/api/v2/";


		private struct MoveInfo
		{
			public enum LearnMethod
			{
				Invalid,
				Egg,
				TM,
				LevelUp,
				Tutor,
			}

			public LearnMethod method;
			public int learnLevel;
			public string moveName;
			public string versionName;
		}

		private static Dictionary<string, string> MoveToTMHMItem = null;
		private static Dictionary<string, string> MoveToTutorMove = null;

		private static void GatherTMHMMovesInfo()
		{
			Console.WriteLine("Detecting TMHM moves:");
			MoveToTMHMItem = new Dictionary<string, string>();

			foreach(var kvp in GameDataHelpers.ItemDefines)
			{
				if (kvp.Key.StartsWith("ITEM_TM") || kvp.Key.StartsWith("ITEM_HM"))
				{
					// These are the "#define ITEM_TM01 123" lines which we want to skip
					if (kvp.Key.Where(c => c == '_').Count() == 1)
						continue;

					string itemName = kvp.Key;
					string moveName = kvp.Key.Substring("ITEM_TM00_".Length);

					if (itemName == "ITEM_TM_CASE")
						continue;

					Console.WriteLine($"\t{moveName} -> {itemName}");
					MoveToTMHMItem.Add(moveName, itemName);
				}
			}
		}

		private static void GatherTutorMovesInfo()
		{
			Console.WriteLine("Detecting Tutor moves:");
			MoveToTutorMove = new Dictionary<string, string>();

			foreach(var kvp in GameDataHelpers.TutorMoveDefines)
			{
				if (kvp.Key.StartsWith("TUTOR_MOVE_"))
				{
					string itemName = kvp.Key;
					string moveName = kvp.Key.Substring("TUTOR_MOVE_".Length);

					if (itemName == "TUTOR_MOVE_COUNT")
						continue;

					Console.WriteLine($"\t{moveName} -> {itemName}");
					MoveToTutorMove.Add(moveName, itemName);
				}
			}
		}

		public static void GenerateProfiles()
		{
			GatherTMHMMovesInfo();
			GatherTutorMovesInfo();

			foreach(var kvp in GameDataHelpers.SpeciesDefines)
			{
				try
				{
					string speciesName = kvp.Key.Substring("SPECIES_".Length).ToLower().Replace("_", "-");

					if (speciesName == "none" || speciesName == "count" || speciesName.StartsWith("old-"))
						continue;

					GenerateProfileFor(speciesName);
				}
				catch(AggregateException e)
				{
					if (e.InnerException is HttpRequestException)
						Console.WriteLine($"\tCaught Http Exception '{e.InnerException.Message}'");
					else
						throw e;
				}
			}

			//GenerateProfileFor("growlithe-hisui");
			//GenerateProfileFor("arcanine-hisui");
		}


		public static void GenerateProfileFor(string monName)
		{
			Console.WriteLine($"Gathering '{monName}' profile");

			JObject monEntry = ContentCache.GetJsonContent(c_API + "pokemon/" + monName);

			string outputFile = Path.Combine(Path.GetFullPath("pokemon_profiles"), monName + ".txt");
			string outputDir = Path.GetDirectoryName(outputFile);
			Directory.CreateDirectory(outputDir);


			StringBuilder content = new StringBuilder();

			content.AppendLine("// == WARNING ==");
			content.AppendLine("// DO NOT EDIT THIS FILE");
			content.AppendLine("// This file was automatically generated by PokemonDataGenerator");
			content.AppendLine("//");
			content.AppendLine($"");

			{
				string[] abilities = new string[3];

				foreach (var obj in monEntry["abilities"])
				{
					string abilityName = obj["ability"]["name"].ToString();
					string rawSlot = obj["slot"].ToString();

					abilities[int.Parse(rawSlot) - 1] = abilityName;
				}

				content.AppendLine($"Abilities:\t{{ {string.Join(", ", abilities.Select((a) => "ABILITY_" + (a == null ? "NONE" : FormatKeyword(a))))} }}");
			}

			{
				string[] types = new string[2];
				foreach (var obj in monEntry["types"])
				{
					string name = obj["type"]["name"].ToString();
					string rawSlot = obj["slot"].ToString();

					types[int.Parse(rawSlot) - 1] = name;
				}

				content.AppendLine($"Types:\t\t{{ {string.Join(", ", types.Select((a) => "TYPE_" + (a == null ? "NONE" : FormatKeyword(a))))} }}");
			}

			{
				HashSet<string> versionsFound = new HashSet<string>();
				List<MoveInfo> foundMoves = new List<MoveInfo>();
				foreach (var moveObj in monEntry["moves"])
				{
					foreach (var versionObj in moveObj["version_group_details"])
					{
						MoveInfo moveInfo = new MoveInfo();
						moveInfo.moveName = moveObj["move"]["name"].ToString();
						moveInfo.versionName = versionObj["version_group"]["name"].ToString();

						string method = versionObj["move_learn_method"]["name"].ToString();
						switch (method)
						{
							case "egg":
								moveInfo.method = MoveInfo.LearnMethod.Egg;
								break;
							case "machine":
								moveInfo.method = MoveInfo.LearnMethod.TM;
								break;
							case "tutor":
								moveInfo.method = MoveInfo.LearnMethod.Tutor;
								break;
							case "level-up":
								moveInfo.method = MoveInfo.LearnMethod.LevelUp;
								moveInfo.learnLevel = int.Parse(versionObj["level_learned_at"].ToString());
								break;

							// Special cases
							//case "stadium-surfing-pikachu":
							//case "light-ball-egg":
							default:
								moveInfo.method = MoveInfo.LearnMethod.Tutor;
								break;

							//default:
							//	throw new NotImplementedException();
						}

						foundMoves.Add(moveInfo);
						versionsFound.Add(moveInfo.versionName);
					}

				}

				foundMoves = foundMoves.OrderBy((m) => m.learnLevel).ToList();

				foreach (var version in versionsFound)
				{
					var movesForVersion = foundMoves.Where(m => m.versionName == version);

					content.AppendLine($"\n");
					content.AppendLine($"== MOVES ({version}) ==");
					content.AppendLine($"Level:");

					foreach(var move in movesForVersion.Where((m) => m.method == MoveInfo.LearnMethod.LevelUp))
					{
						content.AppendLine($"\tLEVEL_UP_MOVE({move.learnLevel}, MOVE_{FormatKeyword(move.moveName)}),");
					}
					content.AppendLine($"\tLEVEL_UP_END");

					content.AppendLine($"\n");
					content.AppendLine($"Egg:");
					foreach (var move in movesForVersion.Where((m) => m.method == MoveInfo.LearnMethod.Egg))
					{
						content.AppendLine($"\tMOVE_{FormatKeyword(move.moveName)},");
					}

					content.AppendLine($"\n");
					content.AppendLine($"Tutor:");
					foreach (var move in movesForVersion.Where((m) => MoveToTutorMove.ContainsKey(FormatKeyword(m.moveName))))
					{
						content.AppendLine($"\tMOVE_{FormatKeyword(move.moveName)},");
					}

					content.AppendLine($"\n");
					content.AppendLine($"TM:");
					foreach (var move in movesForVersion.Where((m) => MoveToTMHMItem.ContainsKey(FormatKeyword(m.moveName))))
					{
						content.AppendLine($"\tMOVE_{FormatKeyword(move.moveName)},");
					}

					content.AppendLine($"\n");
					content.AppendLine($"Leftover moves (unused):");
					foreach (var move in movesForVersion.Where((m) =>
						m.method != MoveInfo.LearnMethod.LevelUp &&
						m.method != MoveInfo.LearnMethod.Egg &&
						!MoveToTutorMove.ContainsKey(FormatKeyword(m.moveName)) &&
						!MoveToTMHMItem.ContainsKey(FormatKeyword(m.moveName))
						)
					)
					{
						content.AppendLine($"\tMOVE_{FormatKeyword(move.moveName)},");
					}
				}

				//content.AppendLine($"{{ {string.Join(", ", types.Select((a) => "TYPE_" + (a == "" ? "NONE" : FormatKeyword(a))))} }}");
			}

			string fullStr = content.ToString().Replace("\t", "    ");
			File.WriteAllText(outputFile, fullStr);
		}

		private static string FormatKeyword(string keyword)
		{
			return keyword.Trim()
				.Replace(".", "")
				.Replace("’", "")
				.Replace("'", "")
				.Replace("%", "")
				.Replace(":", "")
				.Replace(" ", "_")
				.Replace("-", "_")
				.Replace("é", "e")
				.ToUpper();
		}
	}
}
